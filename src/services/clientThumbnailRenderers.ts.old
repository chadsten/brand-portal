/**
 * Client-side document thumbnail renderers
 * Uses Canvas API for 100% web-based thumbnail generation
 * No server dependencies required
 */

// Dynamic imports to prevent SSR issues
let pdfjsLib: typeof import('pdfjs-dist') | null = null;
let mammoth: typeof import('mammoth') | null = null;
let html2canvas: typeof import('html2canvas') | null = null;
let XLSX: typeof import('xlsx') | null = null;

// Initialize libraries only on client side
async function initializeLibraries() {
  if (typeof window === 'undefined') {
    throw new Error('Client thumbnail renderers can only be used in browser environment');
  }

  if (!pdfjsLib) {
    pdfjsLib = await import('pdfjs-dist');
    pdfjsLib.GlobalWorkerOptions.workerSrc = '/pdf.worker.min.js';
  }

  if (!mammoth) {
    const mammothModule = await import('mammoth');
    mammoth = mammothModule.default || mammothModule;
  }

  if (!html2canvas) {
    const canvasModule = await import('html2canvas');
    html2canvas = canvasModule.default || canvasModule;
  }

  if (!XLSX) {
    XLSX = await import('xlsx');
  }
}

export interface ThumbnailRenderOptions {
  width?: number;
  height?: number;
  quality?: number;
  format?: 'webp' | 'jpeg' | 'png';
}

const DEFAULT_OPTIONS: Required<ThumbnailRenderOptions> = {
  width: 800,
  height: 600,
  quality: 0.85,
  format: 'webp'
};

/**
 * Render PDF thumbnail using PDF.js
 */
export async function renderPdfThumbnail(
  pdfBlob: Blob,
  options: ThumbnailRenderOptions = {}
): Promise<Blob> {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  
  try {
    await initializeLibraries();
    if (!pdfjsLib) throw new Error('PDF.js library failed to initialize');

    const arrayBuffer = await pdfBlob.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({
      data: arrayBuffer,
      useWorkerFetch: false,
      isEvalSupported: false,
      useSystemFonts: true
    }).promise;
    
    const page = await pdf.getPage(1); // First page
    
    // Calculate scale to fit within desired dimensions
    const viewport = page.getViewport({ scale: 1.0 });
    const scaleX = opts.width / viewport.width;
    const scaleY = opts.height / viewport.height;
    const scale = Math.min(scaleX, scaleY);
    
    const scaledViewport = page.getViewport({ scale });
    
    // Create canvas
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    if (!context) throw new Error('Failed to get canvas context');
    
    canvas.width = scaledViewport.width;
    canvas.height = scaledViewport.height;
    
    // White background
    context.fillStyle = '#ffffff';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // Render PDF page
    await page.render({
      canvasContext: context,
      viewport: scaledViewport,
      canvas: canvas
    }).promise;
    
    return new Promise((resolve, reject) => {
      canvas.toBlob(
        (blob) => blob ? resolve(blob) : reject(new Error('Failed to create blob')),
        `image/${opts.format}`,
        opts.quality
      );
    });
  } catch (error) {
    throw new Error(`PDF rendering failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Render Word document thumbnail using mammoth.js + html2canvas
 */
export async function renderWordThumbnail(
  docBlob: Blob,
  options: ThumbnailRenderOptions = {}
): Promise<Blob> {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  
  try {
    await initializeLibraries();
    if (!mammoth || !html2canvas) throw new Error('Document libraries failed to initialize');

    const arrayBuffer = await docBlob.arrayBuffer();
    const result = await mammoth.convertToHtml({ arrayBuffer });
    
    // Create temporary container
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = result.value;
    tempDiv.style.cssText = `
      width: ${opts.width}px;
      max-width: ${opts.width}px;
      padding: 40px;
      background-color: white;
      font-family: 'Times New Roman', serif;
      font-size: 12px;
      line-height: 1.5;
      color: #000000;
      position: absolute;
      left: -9999px;
      top: -9999px;
      overflow: hidden;
      word-wrap: break-word;
    `;
    
    document.body.appendChild(tempDiv);
    
    try {
      const canvas = await html2canvas(tempDiv, {
        width: opts.width,
        height: opts.height,
        backgroundColor: '#ffffff',
        scale: 1,
        useCORS: true,
        allowTaint: false,
        logging: false
      });
      
      return new Promise((resolve, reject) => {
        canvas.toBlob(
          (blob) => blob ? resolve(blob) : reject(new Error('Failed to create blob')),
          `image/${opts.format}`,
          opts.quality
        );
      });
    } finally {
      document.body.removeChild(tempDiv);
    }
  } catch (error) {
    throw new Error(`Word document rendering failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Render Excel spreadsheet thumbnail using xlsx + Canvas
 */
export async function renderExcelThumbnail(
  excelBlob: Blob,
  options: ThumbnailRenderOptions = {}
): Promise<Blob> {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  
  try {
    await initializeLibraries();
    if (!XLSX) throw new Error('Excel library failed to initialize');

    const arrayBuffer = await excelBlob.arrayBuffer();
    const workbook = XLSX.read(arrayBuffer, { type: 'array' });
    
    // Get first worksheet
    const firstSheetName = workbook.SheetNames[0];
    if (!firstSheetName) throw new Error('No worksheets found');
    
    const worksheet = workbook.Sheets[firstSheetName];
    if (!worksheet) throw new Error('Worksheet not found');
    
    // Convert to array of arrays
    const jsonData: any[][] = XLSX.utils.sheet_to_json(worksheet, { 
      header: 1,
      defval: '',
      raw: false 
    });
    
    if (jsonData.length === 0) throw new Error('Empty worksheet');
    
    // Create canvas
    const canvas = document.createElement('canvas');
    canvas.width = opts.width;
    canvas.height = opts.height;
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('Failed to get canvas context');
    
    // White background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Calculate cell dimensions
    const maxCols = Math.min(8, Math.max(...jsonData.map(row => row.length)));
    const maxRows = Math.min(25, jsonData.length);
    const cellWidth = (opts.width - 40) / maxCols;
    const cellHeight = 25;
    const startX = 20;
    const startY = 40;
    
    // Set font
    ctx.font = '11px Arial, sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    
    // Draw title
    ctx.fillStyle = '#333333';
    ctx.font = 'bold 14px Arial, sans-serif';
    ctx.fillText(`Sheet: ${firstSheetName}`, startX, 25);
    ctx.font = '11px Arial, sans-serif';
    
    // Draw grid and data
    for (let row = 0; row < maxRows; row++) {
      for (let col = 0; col < maxCols; col++) {
        const x = startX + col * cellWidth;
        const y = startY + row * cellHeight;
        
        // Draw cell border
        ctx.strokeStyle = '#cccccc';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, cellWidth, cellHeight);
        
        // Header row styling
        if (row === 0) {
          ctx.fillStyle = '#f0f0f0';
          ctx.fillRect(x + 1, y + 1, cellWidth - 2, cellHeight - 2);
          ctx.fillStyle = '#333333';
          ctx.font = 'bold 11px Arial, sans-serif';
        } else {
          ctx.fillStyle = '#000000';
          ctx.font = '11px Arial, sans-serif';
        }
        
        // Draw cell content
        const cellValue = (jsonData[row] && jsonData[row][col] !== undefined) ? 
          jsonData[row][col]?.toString() || '' : '';
        const truncatedValue = cellValue.length > 12 ? cellValue.substring(0, 12) + '...' : cellValue;
        
        ctx.fillText(truncatedValue, x + 5, y + cellHeight / 2);
      }
    }
    
    // Add summary info
    ctx.fillStyle = '#666666';
    ctx.font = '10px Arial, sans-serif';
    const maxColumns = jsonData.length > 0 ? Math.max(...jsonData.map(row => row?.length || 0)) : 0;
    ctx.fillText(
      `${jsonData.length} rows Ã— ${maxColumns} columns`,
      startX,
      opts.height - 15
    );
    
    return new Promise((resolve, reject) => {
      canvas.toBlob(
        (blob) => blob ? resolve(blob) : reject(new Error('Failed to create blob')),
        `image/${opts.format}`,
        opts.quality
      );
    });
  } catch (error) {
    throw new Error(`Excel rendering failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Render text file thumbnail using Canvas text API
 */
export async function renderTextThumbnail(
  textBlob: Blob,
  options: ThumbnailRenderOptions = {}
): Promise<Blob> {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  
  try {
    const text = await textBlob.text();
    const previewText = text.substring(0, 3000); // First 3000 chars
    
    // Create canvas
    const canvas = document.createElement('canvas');
    canvas.width = opts.width;
    canvas.height = opts.height;
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('Failed to get canvas context');
    
    // White background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Text styling
    ctx.fillStyle = '#333333';
    ctx.font = '12px "Courier New", "Consolas", monospace';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    
    // Add header
    ctx.fillStyle = '#666666';
    ctx.font = 'bold 14px Arial, sans-serif';
    ctx.fillText('Text Document Preview', 20, 20);
    
    // Reset for content
    ctx.fillStyle = '#333333';
    ctx.font = '12px "Courier New", "Consolas", monospace';
    
    // Wrap and draw text
    const lines = wrapText(ctx, previewText, opts.width - 40);
    const lineHeight = 16;
    const maxLines = Math.floor((opts.height - 60) / lineHeight);
    
    for (let i = 0; i < Math.min(lines.length, maxLines); i++) {
      ctx.fillText(lines[i], 20, 50 + i * lineHeight);
    }
    
    // Add truncation indicator if needed
    if (lines.length > maxLines || text.length > 3000) {
      ctx.fillStyle = '#999999';
      ctx.font = 'italic 11px Arial, sans-serif';
      ctx.fillText('... (content truncated)', 20, opts.height - 20);
    }
    
    return new Promise((resolve, reject) => {
      canvas.toBlob(
        (blob) => blob ? resolve(blob) : reject(new Error('Failed to create blob')),
        `image/${opts.format}`,
        opts.quality
      );
    });
  } catch (error) {
    throw new Error(`Text rendering failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Utility function to wrap text for canvas rendering
 */
function wrapText(ctx: CanvasRenderingContext2D, text: string, maxWidth: number): string[] {
  const words = text.split(/\s+/);
  const lines: string[] = [];
  let currentLine = '';
  
  for (const word of words) {
    // Handle line breaks in the original text
    if (word.includes('\n')) {
      const parts = word.split('\n');
      for (let i = 0; i < parts.length; i++) {
        if (i === 0) {
          const testLine = currentLine + parts[i] + ' ';
          if (ctx.measureText(testLine).width > maxWidth && currentLine !== '') {
            lines.push(currentLine.trim());
            currentLine = parts[i] + ' ';
          } else {
            currentLine = testLine;
          }
        } else {
          if (currentLine.trim()) {
            lines.push(currentLine.trim());
          }
          currentLine = parts[i] + ' ';
        }
      }
    } else {
      const testLine = currentLine + word + ' ';
      const metrics = ctx.measureText(testLine);
      
      if (metrics.width > maxWidth && currentLine !== '') {
        lines.push(currentLine.trim());
        currentLine = word + ' ';
      } else {
        currentLine = testLine;
      }
    }
  }
  
  if (currentLine.trim()) {
    lines.push(currentLine.trim());
  }
  
  return lines;
}

/**
 * Determine the appropriate renderer based on MIME type
 */
export function getRendererForMimeType(mimeType: string): keyof typeof RENDERERS | null {
  const mimeMap: Record<string, keyof typeof RENDERERS> = {
    'application/pdf': 'pdf',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'word',
    'application/msword': 'word',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 'excel',
    'application/vnd.ms-excel': 'excel',
    'text/plain': 'text',
    'text/csv': 'text',
    'text/html': 'text',
    'text/css': 'text',
    'text/javascript': 'text',
    'text/typescript': 'text',
    'application/json': 'text',
    'application/xml': 'text',
    'text/xml': 'text'
  };
  
  return mimeMap[mimeType] || null;
}

export const RENDERERS = {
  pdf: renderPdfThumbnail,
  word: renderWordThumbnail,
  excel: renderExcelThumbnail,
  text: renderTextThumbnail
} as const;